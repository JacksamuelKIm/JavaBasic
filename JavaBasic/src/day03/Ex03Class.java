package day03;

public class Ex03Class {
/*
 *  클래스 컨닝페이퍼
 * 
 *  1. 클래스
 *		클래스란 필드와 메소드를 적어놓은 일종의 설계도이다.
 *		우리가 해당 클래스로 변수를 만들면 그 변수가 어떤 정보를 가질지(=필드)
 *		어떤 기능을 가질 지 (=메소드)를 적어주게 된다
 *  	이렇게 만들어놓은 설계도로 변수를 만들면 그 변수가 바로 객체가 된다.
 *  	우리가 만드는 모든 객체지향 프로그램들은 이러한 객체들이 모여서 하나의 커다란 프로그램이 통제해서
 *  	우리가 필요한 연산을 하고 그 결과값을 받아보는 형태가 된다.
 *  2. 필드
 *  	필드란 해당 객체가 어떤 정보들을 보관할 지를 규정하는 공간이 된다.
 *  	i.e) 학생이란 클래스의 객체라면 이름, 나이,국어 , 수학 점수들을 저장할 수 있어야 한다.
 *  	하지만 학생마다 위와 같은 정보들이 다르다.
 *  	따라서 우리는 클래스에 저 정보들의 자료형과 어떤 이름을 가질 지만 정해준다.
 *  	i.e) String name, int korean............
 *  	그 공간에 값을 저장하는 것은 그 객체를 사용할 곳에서 저장을 하면 된다.
 *  	
 *  3. 메소드
 *  	메소드란 그 객체가 가지고 있는 기능을 선언과 함께 정의해 놓은 것이다.
 *  	예를 들어, 만약 학생의 점수들의 총점을 구하는 기능은 학생마다 다른게 아니라
 *  	모두 똑같이 정의되어 있지만, 그 안의 데이터 값의 차이 때문에 결과가 다르게 나올 뿐이다.
 *		A. 메소드를 선언하는 방법
 *			접근제한자 / (static) / 리턴타입 / 메소드이름(파라미터)
 *
 *			가. 리턴 타입
 *				해당 메소드가 종료되면서 호출된 곳으로 보내줄 데이터의 데이터 타입을 적어주면 된다.
 *				보내줄 때에넨 return이라는 키워드를 이용해서
 *				return 값; 이렇게 보내주면 된다.
 *				만약 메소드 도중에 리턴이 나오면 해당 메소드는 그 지점에서 종료가 된다.
 *				
 *				만약 호출된 곳으로 아무런 값도 보내주지 않는다면, 리턴 타입은 void가 된다.
 *
 *				리턴 타입이 존재하는데, return을 메소드 내부에서 적어주지 않으면 에러가 난다.
 *					"계약이랑 틀리잖아!?"
 *				반대로 리턴 타입이 void인데 return을 적어주면 에러가 난다.
 *			나. Parameter
 *				파라미터는 해당 메소드가 실행될 때 만약 외부로부터 어떤 값을 받아와야 한다면
 *				그 값을 사용하기위해 일종의 변수처럼 우리가 ()안에 적어주면 된다.
 *				외부에서 보내줄 때에는 다른 이름의 변수이거나 혹은 그 값 자체가 넘어올 수 있지만
 *				해당 메소드 내부에서는 파라미터의 적힌 이름대로 쓰면 된다.
 *				변수처럼 사용 가능하기 때문에 우리가 "매개변수"라고도 한다.
 *				파라미터는 우리가 변수를 선언하듯
 *					데이터타입 이름을 적어주면 된다. 
 *
 *		
 *
 *  4. 접근제한자
 *  	접근 제한자란 해당 필드 혹은 메소드가 다른 클래스 혹은 다른 패키지에서도 접근 가능한 지 결정하는 키워드이다.
 *  	public: 외부 패키지의 다른 클래스나 같은 패키지의 다른 클래스든 어디서든 접근 가능  	
 *  	protected: 외부 패키지의 경우 "상속"받는 다른 클래스나, 내부 패키지의 경우 아무 클래스이든 접근 가능하다. 	
 *  	default: 외부 패키지면 접근이 불가능하다. 내부 패키지의 다른 클래스들만 접근 가능하다.
 *  			 어떤 접근제한자도 적어주지 않을 경우 자동으로 default가 적용된다.
 *  	private: 외부 패키지건 같은 패키지건 다른 클래스이면 무조건 접근이 불가능하다.
 *  
 *  5. static  //2세대 절차지향 언어에서 가져온 개념. 꺼려짐. import랑 관계 없음	
 *		static키워드는 해당 메소드나 상수, 필드 등을 객체 선언없이 곧장 사용가능하게 하는 메소드 메모리 영억에 등록시키는 키워드이다
 *		만약 스테틱 메소드가 다른 상수나 필드 혹은 메소드를 사용하게 된다면 그 다른상수, 필드, 메소드돋 모두 스태틱 키워드를 붙여주어야 한다.
 *		static 메소드의 경우 객체 선언을 해서 메소드 호출을 하지 말고 클래스.메소드()로 실행하는 것이 원칙이다.   
 *		예시: Scanner의 경우 우리가 스캐너의 객체를 만들어서 객체.nextInt()를 사용했지만
 *			 스태틱이 붙을 경우 Integer.parseInt(값) 이런식으로 객체선언을 하지 않는다.
 *	  
 *  6. 생성자(Constructor)
 *  	생성자란 해당 클래스의 객체가 new 키워드와 함께 초기화 될 때, 만약 진행해야할 작업이 있으면
 *  	생성자를 만들어서 해당 작업들을 진행해 주면 된다.
 *  	만약 아무런 작업도 필요없어서 우리가 아무것도 적어주지 않으면 자바에서 기본적인 생성자를 제공해준다.
 *  	기본 생성자의경우 필드만 초기화 해 주는데
 *  	만약 기본형(primitive)데이터 타입의 필드인 경우 0으로 초기화하고
 *  	참조형(referecne) 데이터 타입의 필드인 경우 null로 초기화한다.
 *  
 *  	만약 우리가 생성자를 만들었고, 그리고 그 생성자에 파라미터가 존재하면 더 이상 파라미터가 없는 기본 생성자는 사용할 수 없다.
 *  	만약 파라미터가 있는 생성자와 없는 생성자 2개다 사용하고 싶다면 파라미터가 없는 생성자까지 만들어주어야 한다.
 *  
 *  	생성자는 내부의 데이터를 초기화하는 용도가 주이기 때문에 리턴 타입이 조냊하지 않는다
 *  	또한 그 클래스의 초기화 작업을 담당하기 때문에 메소드의 이름이 클래스의 이름과 똑같다.
 *  
 *  
 *  
 *  7. null
 *  	null이란 참조형 데이터타입에서만 가능한 경우인데,
 *  	참조형 데이터의 경우 stack 영역에 힙(hip?heap?) 영역으로 향하는 메모리 주소가 적혀있다.
 *  	그리고 해당 힙 영역에 그 참조형 데이터의 상세사항이 정의되어 있는데
 *  	만약 해당 힙 영역의 그 메모리 주소에 아무것도 없다면...?
 *  	이 아무것도 없는 상태를 우리가 null이라고 하고 null인 상태에서는 필드나 메소드 접근을 아예 할 수 없다.
 *  	만약 필드나 메소드 접근을 하려 한다면, NullPointerException이 발생해서 오류가 난다.
 *  	따라서 우리가 객체를 사용하려면 항상 생성자를 통한 초기화를 해주어야 한다.
 *  	 
 *  8. Java의 Object 메소드들
 *  	우리가 만드는 모든 클래스 그리고 자바에 존재하는 모든 클래스들은 모두 java.lang.Object라는 클래스를 상속받는다.
 *  	이 java.lang.Object 안에는 기본적으로 갖추어야할 몇몇 메소드들을 선언과 정의해놓았다.
 *  	하지만 그 메소드들은 어느 메소드에도 적용시킬 수 있게 매우 간단하게 적혀져있다.
 *  	따라서 우리가 우리 클래스에 맞추기 위해서는 필요한 메소드들을 재정의해 주어야 한다.
 *  	
 *  	재정의는 다른말로 override라고 하고,
 *  	재정의를 할 때에는 부모클래스에 적혀 있는 메소드 선언과 똑같이 선언해 주어야 한다!
 *  	만약 부모클래스에 어떻게 정의가 되었는지 궁금하다면
 *  	객체. 이라고 입력할 때 나오는 박스에서 해당 매소드를 찾아보면 된다.
 *  
 *  	 	가. toString()
 *  			System.out.prinln()의 경우 파라미터로 객체가 들어온다면
 *  			해당 객체에서 toString()을 실행한 결과값을 출력한다.
 *  			하지만 java.lang.Obejct의 경우 우리 클래스 내부 필드가 무엇이 있고
 *  			무슨 값이 존재하는 지 절대 알 지 못한다.
 *  			그렇다면 java.lang.Object가 알고 있는 정보 중에서 어떤 클래스 객체이던 간에
 *  			적용시킬 수 있는 정보는 무엇이 있을까?
 *  			바로 해당 객체를 만드는 클래스의 파일 위치(패키지.클래스이름) 그리고
 *  			해당 객체가 어디에 정의되어있는지(메모리주소값) 이 2가지 정보는 java.lang.Object가 
 *  			말할 수 있다.
 *  			
 *  			하지만 이러한 정보가 우리가 필요한 정보가 아니기 때문에, 우리는 java.lang.Object가 상속해준 
 *  			toString() 메소드를 재정의해 주어야 한다.
 *  
 *			나. equals()
 *				java.lang.Obejct 클래스 안에는 equals()메소드가 정의되어 있다.
 *				하지만 Object 클래스는 우리 클래스 객체안의 
 *				어떤 필드를 비교해서 정보들이 같으면 true, 다르면 false를 리턴할 지 모른다
 *				그래서 java.lang.Obejct 안의 equals()는 객체의 메모리 주소값 비교를 하는 코드만 들어있다.
 *						"student1 == student2"
 *				따라서 우리가 객체의 정보를 비교해서 같은지 다른지를 equals()메소드를 통해서 할려면
 *				우리가 equals()메소드를 재정의 해야한다. 
 * 
 *  9. method overload
 *  	메소드 오버로드란 같은 이름의 메소드이지만 파라미터가 다르게 정의해 주는 것을 메소드 오버로드라고 한다.
 *  	메소드 오버로드를 해주는 가장 큰 이유는 같은 기능이지만 파라미터가  달라지는 것에 대비해서 이름을 통일시킬 수 있게 해주는 것이다.
 *  	메소드 오버로드의 가장 대표적인 예가 바로 System.out.println()이다.
 *  	오버로드를 할 때 주의해야하는 것은 파라미터가 반드시 달라야지만 에러가 없다는 것이다.
 *  	그렇다면 파라미터가 다르다는 것은 어떤 의미일까?
 *      파라미터가 다르다는 것은 ()안의 파라미터의 데이터타입 순서가 다르다 는 것을 의미한다.  
 *  
 *  	1. Student(int age, String name)
 *  	   Student(String name)
 *  
 *      2. Student(String name)
 *         Student(String name)
 *         
 *      3. Student(String name)         -)자바는 name이든 jumin이든 신경 안쓰고 String int등 순서만 본다.
 *         Student(String jumin)      -> Student("가나다");   
 *  
 *  10. 데이터 은닉화(data hiding)와 캡슐화 (data encapsulation)
 *  	이제 더이상 필드나 외부가 사용하지 않는 메소드의 경우 public, protected, default를 사용하지 않는다.
 *  	이제 모든 필드는 private으로, 외부가 사용하지 않는 메소드도 private으로 설정한다.
 *  	그러나 필드나 메소드에 private을 붙이면 더이상 다른 클래스가 해당 필드나 메소드를 직접 접근할 수 없게 된다.
 *  	즉, 더 이상 접근 연산자인. 으로 우리가 필드에 값을 넣거나 호출할 수 없게 된다.
 *  	
 *  	그렇다면 private으로 설정된 필드는 어떻게 접근해야하는가?
 *  	바로 메소드를 통해서 우리가 값을 저장하고
 *   	값을 호출하는 방식을 사용해야 한다!
 *   
 *      값을 저장할 때엔 setter 메소드를 사용하고
 *      필드에 저장되어 있는 값을 불러올 때에는 getter 메소드를 사용하면 된다.
 *      
 *      이렇게 메소드를 통해서 우리가 필드에 접근하는 이유는 메소드를 이용하면 해당 값을 검증하기도 쉽고
 *      또 다른 외부에서 혹시라도 함부로 값을 변경하는 것을 막을 수 있기 때문이다.	
 *  
 *  	가. setter 만들기
 *  		 setter는
 *  		 public void set필드이름(필드타입 필드이름) {
 *           	 this.필드이름 = 필드이름; *           	
 *           }
 *		나. getter 만들기
 *		     public 필드이름 get필드이름() {
 *               return 필드이름;
 *           }
 *  
 *  11. 다형성(Polymorphism)
 *	    다형성이란 "다"양한 "형"태를 지닌 "성"격
 *    파라미터와 같은 곳에 우리가 부모 클래스를 적어도 그 부모 클래스를 상속받는 모든 형태의 자식 클래스
 *    혹은
 *    부모 인터페이스를 적어주었을 때 그 인터페이스를 상속받는 클래스가 올 수 있다.
 *    예를 들어
 *    equals()메소드의 파라미터로 Object obj가 적혀있으면
 *    Object를 상속받는 모든 클래스들이 파라미터로 올 수 있다.
 *    즉 Obejct는 자바의 모든 클래스의 조상이기 때문에 파라미터 안에() Object obj라고 적는 순간
 *    파라미터로 어떤 클래스의 객체든 올 수 있게 된다.
 *    핵심은 Oject 클래스라는 것!!!
 *  
 *  
 *  
 *  
 */
	
	
	
	

}
