	8월 18일 2020년

	Day 07 학습정리


1. 배열

연속된 데이터
기본 타입의 배열보다는 객체를 저장하는 형태로 더욱 많이 쓴다
3차원 배열까지 쓸 필요는 거의 없다. 객체를 넣으면 되므로

[]은 배열 이름 뒤에 붙던 앞에 붙던 상관없다

heap 메모리에 저장된 것을, stack에 저장해 놓은 배열주소를 통해서 참조만 하는 것
참조변수가 없으면, 설령 배열이 생성되어 있어도 어디에 저장되어 있는지를 모르기 때문에 접근 불가

리터럴 : 선언과 동시에 초기값을 설정해주는것 
int intArray[] = {1, 2, 3, 4, 5, 6} 배열 리터럴

int타입의 배열 만들면 4byte짜리 참조변수가 만들어짐( 배열공간 자체의 크기와는 다름)
  
배열은 타입이 배열. []을 붙임으로서 배열타입이 됨

인덱스에 그 배열과 같은 사이즈의 수를 넣지 않도록 조심하자. Bound를 벗어나므로.
배열참조변수 만 만들어놓고, 배열 요소의 값을 넣거나 빼는 것 불가능.


int intArray[] = new int[5]
int myArray[] = intArray; 단지 myArray에게 intArray라는 배열의 주소값만 할당해주는 것임

 
같은 배열공간을 사용!


배열의 주소값 말고 그 요소 출력할때는 String으로 바꿔서
	System.out.println(Arrays.toString(arr));

배열의 크기를 확인한다.
	int size= arr.length;
	System.out.println("배열의 크기: " + size);
	
## 일일히 배열.length 하는 것은 heap 메모리까지 가서 다시 가져오는 것이라 시간 걸림
배열에다가 변수 넣어주고 하는 것이 속도가 더 빠름. performance향상에 당연히 좋음

total을 구할 때 꼭 total = total+xxx; 해줄 필요는 없다.
보통 total =0; 이렇게 해주는 것은 초기화를 해줘야 loop에서 그 값을 뺄 수 있으니까!!!		


eNum 상수 객체		