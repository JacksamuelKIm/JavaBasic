	Day 12 학습정리 / 8월 25일 2020년

	
1. char는 기본적으로 정수형이다. print메소드로 출력시 문자로 나오는 것은 어디까지나 메소드 자체의 설정때문임

private void way03() { 
		System.out.print("Type in the damn letter!!>>>");		
		char input = scan.next().charAt(0);		
		System.out.println(input);
		
		for(char ch = 'a'; ch<=input; ch++) {  //숫자처리되는건가? ㅇㅇ
			for(char j = 'a'; j<=input-(ch-'a'); j++) {
				System.out.print(j); // print 메소드의 내용에 의해서 strin으로 변환되어(?) 출력되는것일 뿐 숫자임
			}
			System.out.println(); // print 메소드는 기본적으로 문자열출력
		}
	}
	
	
2. 절차지향 프로그램은 제어문에 많은 영향을 받는다	 

3. 클래스와 객체 
	클래스는 하나의 설계도 혹은 틀이다.추상적인 개념
	객체는 실제로 존재하는 물건. 생성되면서 heap 메모리에 공간 생김!!!!
	
	1) 특징
	(1) 캡슐화
	(2) 상속  - 자식 클래스가 부모 클래스를 선택! 기능이 확장되어야 상속이지 그대로 가져다 쓰면 같은 클래스임
		          말이 상속(inheritance)이지 사실은 확장(extends)가 더 정확한 표현. 기존 특징위에 더 추가하는 것
		     i.g) 승용차 => SUV => Van
		          그러나 단점은 과거 버전들을 계속 받다보니까 프레임워크든 라이브러리든 용량이 계속 늘어남.
		          
	(3) 다형성  - 가장 중요하다! 이것을 위해서 1,2가 존재
	
	
	2) 캡슐화의 이유
	외부에서 맘대로 접근해서 데이터를 변경시킬 수 있기 때문에
	
	3) 클래스 선언
	* c언어에는 클래스 없고 구조체만 있다. 구조체에는 필드만 존재하고 메소드 없음. 오히려 배열에 가까운 형태(데이터만 저장)
	* 자바에는 당연히 구조체가 없다. 클래스에 필드값만 있으면 구조체랑 비슷
	
	
	4)
	 클래스 = 필드 + 메소드
	 클래스는 사용자 정의 데이터 타입
	 접근지정자가 생략되면 디폴트 접근지정자(패키지멤버)
	 같은 패키지내에서는 같은 이름의 클래스가 존재할 수 없다
	 
	 
	 5) 메소드 오버로딩
	 동명이인을 만드는  것. 
	 시그니쳐: 구분을 위해서 매개변수의 모양 혹은 타입 혹은 수가 달라야 한다
	 		단, 접근지정자와 리턴형은 이것과 관계 없음
	println이 좋은 예. 이름만 같을 뿐인 다른 애들이 수십가지
	
	cf)오버로딩 (메소드 추가) / 오버라이딩(상속관계에서 메소드 재정의)
	
	생성자도 메소드이므로 시그니쳐가 다른, 여러개의 생성자 메소드를 만들 수 있다.
	
	6) Varargs(Variable length arguments) - 가변적인 변수
	main의 (String[] args)도 일종의 Varargs
	
	
	
	
	
	